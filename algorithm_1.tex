\documentclass{jsarticle}
\begin{document}

\title{『アルゴリズム設計マニュアル(上)』要点まとめ}
\author{ぱろすけ}
\maketitle

\setcounter{section}{-1}

\section{この文書について}
専ら自身の学習のために趣味で作成したものです。これさえ読み返せば内容が思い返せる（必要に応じて参照できる）ことを目指します。



\section{アルゴリズム設計への導入}
\textbf{挿入ソート}は、ひとつの要素から始め、まだソート済み列に加えられていない要素をひとつずつ適切な位置に挿入する。アルゴリズムの一例。

\subsection{ロボットツアーの最適化}
要するに巡回セールスマン問題。近い点に移動し続ける\textbf{最近接点}ヒューリスティックも、最も近いチェーンの端点を結んでゆく\textbf{最近接ペア}も、うまくいかない。最適解を求めるにはすべてのパターンを試す他ないが現実的な計算量ではない。

\subsection{適切な仕事の選択}
映画撮影スケジューリング問題。適切なヒューリスティックにより解ける例。

\subsection{正しさの論証}

\subsubsection{アルゴリズムの表現}
アルゴリズムは自然言語、擬似コード、プログラミング言語で表し得るが、アイディアが明確に現れるような表現法を選ぶこと。

\subsubsection{問題と性質}
一般化映画撮影スケジューリング問題には効率の良い解はない。問題を正しく形式化することが重要。定義が曖昧に過ぎたり、複雑すぎる目標を設定したりしやすい。

\subsubsection{間違いを実証する}
反例は\textbf{立証可能性}と\textbf{単純性}を持つべきである。そのためには小さな例を網羅的に考え、同点に持ち込んだり極端なものを探して弱点を見つけると良い。

\subsubsection{帰納法と再帰}
帰納法は証明に便利だよと書いているだけ。

\subsubsection{総和}
等差級数の場合、$ n $次式の和は$ n+1 $次式になる。等比級数は比が$ 1 $より小さいとき収束するが、これはアルゴリズムの解析上便利なことがある。

\subsection{問題のモデル化}
モデル化とは応用問題を厳密な形式に変換すること。

\subsubsection{組合せオブジェクト}
用語と登場シーンの説明。順列、部分集合、木、グラフ、点、多角形、文字列。きちんと定義された構造とアルゴリズムの言葉でモデル化するよう心がける。

\subsubsection{再帰的なオブジェクト}
一部を削除しても同じものである。順列、部分集合、木、グラフ、点、多角形、文字列、すべて再帰的なオブジェクトといえる。

\subsection{設計奮戦記について}

\subsection{ボクの設計奮戦記：超能力のモデル化}
モデル化を正確に行うことは大事だよという話。いきなり間違ったモデル化をされて混乱する。



\section{アルゴリズム解析}

\subsection{計算のRAMモデル}
Random Access Machine は計算量を考えるときの単純なコンピュータのモデル。メモリは無限に持つ。アルゴリズムの話ではだいたい有用。

\subsubsection{最悪、最良、そして平均の計算量}
基本的には最悪計算量だけ考えれば良い。

\subsection{ビッグオー記法}
実際の計算量はコードに依存し、グラフのでこぼこも多い。しかし実用的にはオーダーで考えれば良い。$ f(n)=O(g(n)) $は$c \cdot g(n)$ が $f(n)$ の上界であることを意味する。$ f(n)= \Omega (g(n)) $は$c \cdot g(n)$ が $f(n)$ の下界であることを意味する。$ f(n)= \Theta (g(n)) $は$c_1 \cdot g(n)$ が $f(n)$ の上界で$c_2 \cdot g(n)$ が $f(n)$ の下界であることを意味する。

\subsection{増加率と支配関係}

\subsubsection{支配関係}
よく現れるクラスと支配関係の話。特に難しい話はない。

\subsection{ビッグオーを使いこなす}
特に難しい話はない。

\subsubsection{関数の加算}
\subsubsection{関数の乗算}

\subsection{効率に関する議論}

\subsubsection{選択ソート}
選択ソートは残りの要素のうち最も小さいものをソート済み列に加える。計算量は$ \Theta(n^2)$になる。簡単。

\subsubsection{挿入ソート}
挿入ソートの計算量は$O(n^2)$になる。簡単。

\subsubsection{文字列パターンマッチング}
単純な文字列パターンマッチングについての計算量の細かな議論。落ち着けば何も難しいことはない。

\subsubsection{行列の乗算}
$3$乗のアルゴリズムであることは明らか。

\subsection{対数とその応用}
対数が現れる例をいくつか示す。

\subsubsection{対数と$2$分探索}

\subsubsection{対数と木}

\subsubsection{対数とビット}

\subsubsection{対数と乗算}
任意の$a$と$b$について$a^b=\exp(b \ln a)$と計算できる。

\subsubsection{高速な指数計算}
大きな$n$について$a^n$を計算するときは$a^n=a(a^{[n/2]} )^2$とすると高速。これは分割統治法の一種。

\subsubsection{対数と総和}
調和数について$H(n)=\sum^{n}_{i=1} 1/i \sim \ln n$が成り立つ。これは計算量の解析に使えることがある。クイックソートなど。

\subsubsection{対数と刑事裁判}
合衆国では詐欺罪の損害額と量刑は対数的な関係にある。だから一気にたくさん騙そう。

\subsection{対数の性質}
アルゴリズムの解析では、定数倍の違いにしかならないため、対数の底が何であるかは無視して良い。

\subsection{ボクの設計奮戦記：ピラミッドの謎}
ナップザック問題をスパコンで力ずくで解こうとしたけど無理だったけれど、アルゴリズムを工夫したら手元のコンピュータでも容易に解けた、という話。アルゴリズム的には『プログラミングコンテストチャレンジブック』の最初に出てきたものと酷似している。　

\subsection{高度な解析}
高度な話題であり、上巻には他に現れないが、下巻で有用であるもの。

\subsubsection{難解な関数}
逆アッカーマン関数は、きわめてゆっくり増加する関数であり、かなり大きな$n$についても$\alpha (n)<5$である。$\log n / \log \log n$は次数が$\log n$である木の高さとして現れる。

\subsubsection{極限と支配関係}
$ n! \gg c^n \gg n^3 \gg n^2 \gg n^{1+\varepsilon} \gg n \log n \gg n \gg \sqrt{n} \gg \\ \log^2 n \gg \log n \gg \log n / \log \log n \gg \log \log n \gg \alpha (n) \gg 1$



\section{データ構造}
コンテナ、辞書、優先順位付きキューについて、配列とリストでの実装を詳説する。

\subsection{連続データ構造と連結データ構造}
連続データ構造とはメモリ上で連続しているデータ構造であり、配列、行列、ヒープ、ハッシュ表などが含まれる。連結データ構造とはいくつかのメモリ領域がポインタで結ばれる構造であり、リスト、木、隣接リストなどが含まれる。

\subsubsection{配列}
配列はメモリの局所性により高速キャッシュメモリを活かすことができる。配列に対し合計$n$回の挿入を行うとして、動的配列で実現するとその総移動回数は$2n$回であるから、この計算量はなんと$O(n)$となり、静的配列の場合と等しい。

\subsubsection{ポインタと連結構造}
C言語によるリスト構造の実現の話。

\subsubsection{比較}
連結リストはメモリを食うが挿入と削除は簡単。リストも配列も再帰的なオブジェクトであることに留意すべき。

\subsection{スタックとキュー}
コンテナとはデータを内容に無関係に出し入れするデータ構造のこと。スタックでもキューでも平均待ち時間は同じ。

\subsection{辞書}
辞書の概要と、実装の違いによる基本操作の計算量の違いについて述べている。長いけれども特に難しい点はない。

\subsection{$2$分探索木}
探索が高速でかつ更新も柔軟なものの例としての$2$分探索木。ある頂点について、左部分木のすべての頂点はその頂点より小さく、右部分木のすべての頂点はその頂点より大きい。このような木は複数の形で存在し得る。

\subsubsection{$2$分探索木の実装}
木の高さを$h$とすると、ある要素の探索は$O(h)$、最小要素の探索も$O(h)$である。すべての頂点と辺を横断する際は、各頂点について左部分木、自身、右部分木の順で処理すれば良く、$O(n)$で済む。挿入については、可能な場所はただひとつであり、それは探索により見つかり、定数時間で追加を行え、$O(h)$である。削除の場合は、その頂点をその次の値で置き換えると考え、右部分木の最小値をそこに割り当てる。

\subsubsection{$2$分探索木はどれほどよいか？}
基本操作はすべて$O(h)$で行え、挿入順がランダムの場合は平均の木の高さは$O(\log n)$になる。

\subsubsection{平衡探索木}
高さが常に$O(\log n)$になる平衡探索木が提案されている。詳細についてはここでは触れられない。平衡探索木を使うことで$O(n \log n)$の様々なソートが提案される。

\subsection{優先順位付きキュー}
優先順位付きキューもいろいろな実装があるが、最小要素の位置を別に持つことでどのような実装でも定数時間で見つけることができるようになる。ただしこのときは削除に余計な時間がかかる。

\subsection{ボクの設計奮戦記：三角形を連ねる}
きちんとデータ構造を選びましょうねという話。

\subsection{ハッシングと文字列}

\subsubsection{衝突の回避}
ハッシュ値が衝突することがある。連鎖法はハッシュの各要素を隣接リストとすることで回避する。開アドレス法では、既に埋まっていた場合、その次の位置に要素を配置する。探索するときは、本来あるべき位置から連続してある要素をすべてチェックする。削除する場合は、そのあとに連続する要素をすべて再挿入する。ぐぐると、削除済みというフラグをつければ良いという記述もある。

\subsubsection{ハッシングを用いた効率的な文字列マッチング}
Rabin-Karp のアルゴリズム。部分文字列パターンマッチング問題において、テキスト文字列のすべての位置からの文字列をハッシュ化しておくことにより、ハッシュ表をチェックする問題になる。$n$文字と$m$文字のマッチングでは$O(n)$の表を構成することになり、ハッシュの計算に$O(m)$かかる。しかし、ハッシュは実は計算結果を活かして定数時間で行うことが可能である。それゆえ、だいたい$O(n+m)$時間で走らせることが可能になる。

\subsubsection{ハッシングによる重複検出}
ハッシングは、重複文書の検出や、盗作の検出、ファイルのハッシュ化による暗号化などの応用がある。ハッシングはランダム化アルゴリズムにおける基本的なアイディアで、$\Theta (n \log n)$や$\Theta (n^2)$となるような問題にも線形時間のアルゴリズムをもたらす。

\subsection{特定目的のデータ構造}
文字列にはサフィックス木とサフィックス配列があり、パターンマッチングに用いられる。幾何的データ構造にはkd木があり、高速な探索を可能にする。集合データにはビットベクトルがある。これらは下巻で詳しく述べられる。

\subsection{ボクの設計奮戦記：数珠つなぎ}
$2$分探索木で探す、ハッシュを用いる、サフィックス木、圧縮サフィックス木、と改良することで問題を解けたよという話。サフィックス木の詳細は下巻。



\section{ソートと探索}

\subsection{ソートの応用}
配列中に任意の要素kが現れる回数を知る良い方法は、配列をソートし、$k - \varepsilon$と$k + \varepsilon$の位置を探すことである。また、\textbf{凸包}を構成する良い方法は、ある軸ですべての点をソートし、その順で凸包に点を加えてゆくことである。新たな点は必ず凸包をなし、かつ削除すべき点は新たな点によって作られる領域にあるため効率が良い。ふたつの配列の共通要素を持つか判定するには小さい方をソートしたのち大きい方の各要素を探すことが考えられるが、実用的にはハッシュを用いるのが最良である。

\subsection{ソートの実際}
もとの並びの相対的な順序を崩さないものを\textbf{安定ソート}と呼ぶ。

\subsection{ヒープソート：データ構造による高速ソート}
選択ソートは素直に実装すると$O(n^2)$だが、最小要素の検索にヒープや平衡2分木を用いると$O(n \log n)$となる。ヒープソートは、実際のところはヒープを用いた選択ソートに過ぎない。

\subsubsection{ヒープ}
\textbf{ヒープ}は2分木であり、minヒープでは親は2つの子より小さな値を持つ。これは配列を用いることにより効率よく実現できる。ヒープの高さは常に$[ \lg n]$である。

\subsubsection{ヒープを構成する}
ヒープに要素を追加するときは、配列の空きの最初の要素に配置する。もしその値が親より小さければ親と要素を入れ替える。これは再帰的に行う。

\subsubsection{最小要素を取り出す}
最小要素は根であるから単にそれを参照すれば良い。空きはもっとも右端にある要素で埋める。もしこれが2つの子より大きければそれと入れ替える。これも再帰的に行う。ヒープソートは\textbf{インプレースソート}であり、ソートする要素を格納する配列以外に余分なメモリを使わない。

\subsubsection{ヒープの高速な構成法}
ひとつずつ要素を加えることでヒープを構成するのではなく、すべての要素を配置してからヒープ内を整理するほうが効率が良い。子を持つものだけ整合性をチェックすればよく、かつそのとき木は概ね低いからである。これはほぼ線形時間で済む。

ヒープの$k$番目に小さい要素が$x$以上かを判定したいとき、これを$x$より小さいものが$k$個以上かと読み替える。そして、$x$より小さい節を次々と訪問し、その数を数える。これが$k$を超えたら終了する。訪問する節の数は親と子2つで高々$3k$なのでこれは$O(k)$のアルゴリズムである。頭良い。

\subsubsection{逐次挿入によるソート}
挿入ソートのような方法を\textbf{逐次挿入}と呼ぶ。これもデータ構造に平衡2分木を用いると$O(n \log n)$で済む。

\subsection{ボクの設計奮戦記：飛行機のチケットをくれないか}
とりあえず飛行機のチケットの値段はものすごい複雑な感じになってることはわかった。

\subsection{マージソート：分割統治法によるソート}
\textbf{マージソート}はランダムアクセスに頼ることがないのが利点である。一方で、配列をソートするための補助バッファが必要となることが欠点である。部分配列はキューにコピーすると良い。

\subsection{クイックソート：ランダム化によるソート}
実装について書いてあるのでさすがに書けるようにしとくとよさそう。

\subsubsection{直観：クイックソートの平均の場合}
ランダムな2分探索木では$n$回の挿入の後の平均の高さは$2 \ln n$である（証明なし）。これは$1.386 \lg n$なのでそれほど高くはない。ゆえに計算量は$O(n \log n)$であるといえる。

\subsubsection{ランダム化アルゴリズム}
決定的なクイックソートのアルゴリズムでは必ず最悪の入力例が存在する。そこで、入力を予め\textbf{ランダム化}しておくことで計算量の期待値を$\Theta (n \log n)$とできる。ランダム化はサンプリングやハッシング、探索などでも用いられる。

\subsubsection{クイックソートは本当にクイック？}
適切に実装されたクイックソートはマージソートやヒープソートよりたいてい2,3倍早い、らしい。最も内側のループでの操作がより単純だから。

\subsection{分配ソート：バケットを用いたソート}
名前をソートするとき、まず頭文字別に分け、それぞれをソートすると効率的である。これを\textbf{バケットソート}あるいは\textbf{分配ソート}といい、データが均一のときに強い。実装などの細かい話はなし。

\subsubsection{ソートの下界}
ソートは$n!$の順列のそれぞれについて異なる動きをしなければならない。そのような木を考えると高さは$\Theta (n \log n)$になる。これがソートの下界である。このように自明でない下界が得られるアルゴリズムは少ない。

\subsection{ボクの設計奮戦記：スキーナの抗弁}
非常に大きなデータをソートするときはいろいろ話が違うよねという話。

\subsection{2分探索と関連アルゴリズム}

\subsubsection{出現の数え上げ}
ソートされた配列中で要素$k$の出現回数を求める場合、2分探索を改造して他の要素との境界を求めるようにすると高速に求まる。

\subsubsection{片側2分探索}
配列の要素数の上限がわからないとして、配列中の要素の転換点を求めたい。その場合は$A[1],A[2],A[4],A[8],...$と探索して2分探索の窓を決定すると早い。

\subsubsection{平方根とその他の根}
2分探索で平方根や方程式の解を求められるよねという話。

\subsection{分割統治法}
分割統治法は、問題を（たとえば）半分に分割しそれぞれを解く。

\subsubsection{再帰式}

\subsubsection{分割統治法の再帰式}
Strassenは$n \times n$行列の積を$n/2 \times n/2$行列の積7つに分割することにより、積を$O(n^{2.81})$で計算するアルゴリズムを得た。

\subsubsection{分割統治法の再帰式を解く}
分割統治法の再帰式$T(n)=aT(n/b)+f(n)$を簡単に解く\textbf{マスター定理}の紹介。ぐぐって使えれば良い。ここでは直感的な解釈も示されている。

\end{document}
